---
title: "R example"
parent: Getting started
---

```{r init, include=FALSE}
library(tidyverse)

source("../R/md_helpers.R")

# change wd to where the files are located
knitr::opts_knit$set(root.dir = "examples/hello_world_r/") 
```

This vignette demonstrates how to wrap a simple 'hello world' R script with viash.

## Demonstration
Given the files and meta files in the [examples/hello_world_r](examples/hello_world_r) directory, we demonstrate the functionality of viash in running the component 
with multiple backends.

#### Run the component
By running the component, it will output "Hello world!", followed by any other inputs provided to it.

```{bash, eval=FALSE}
cd examples/hello_world_r
viash run config.vsh.yaml -- I am viash!
```
```{bash, echo=FALSE}
viash run config.vsh.yaml -- I am viash!
```

#### Run the component with a Docker backend
It can also be run with a Docker backend by specifying the `-p` or `--platform` parameter.

First, you need to let viash set up the Docker container by pulling it from Docker Hub.
```{bash}
viash run config.vsh.yaml -p docker -- ---setup
```

You can run the component with viash in the backend as follows.
```{bash}
viash run config.vsh.yaml -p docker -- General Kenobi. --greeter="Hello there."
```

#### Export as an executable
Now that we know what the component does, we can export the functionality as an executable.
```{bash}
viash build config.vsh.yaml -p docker -o output
output/hello_world And now, as an executable.
```

#### viash automatically generates a CLI
By running the command with a `--help` flag, more information about the component is provided.
```{bash}
output/hello_world_r --help
```

#### viash allows testing the component
To verify that the component works, use `viash test`. This can be run both with or without the Docker backend.
```{bash}
viash test config.vsh.yaml -p docker
```

## Developing a new component

The first step of developing this component, is writing the core functionality of the component, in this case an R script. 

#### Write a script in R
This is a simple script which prints a simple message, along with any input provided to it through the `par["input"]` parameter.
Optionally, you can override the greeter with `par["greeter"]`.

```{r, echo = FALSE}
print_file("script.R")
```

Anything between the `## VIASH START` and `## VIASH END` lines will automatically be replaced 
at runtime with parameter values from the CLI. Anything between these two lines can be used to 
test the script without viash:

```{bash}
Rscript script.R
```

Next, we write a meta-file describing the functionality of this component in YAML format.

#### Describe the component with as a YAML

A [viash config](../config) file describes the behaviour of a script and the platform it runs on.
It consists of two main sections: `functionality` and `platforms`.


```{r, echo = FALSE}
print_file("config.vsh.yaml", "yaml")
```

The [functionality](../config/functionality) section describes the core functionality of the component, such as 
its inputs, outputs, arguments, and extra resources. For each of the arguments, specifying
a description and a set of argument restrictions help create a useful command-line interface.
To ensure that your component works as expected, writing one or more tests is essential.

The platforms section specifies the requirements to execute the component on zero or more platforms.
The list of currently supported platforms are [Native](../config/platform-native), [Docker](../config/platform-docker),
and [Nextflow](../config/platform-nextflow). If no platforms are specified, a native platform with no 
system requirements is assumed.


### Writing a first unit test
Writing a unit test for a viash component is relatively simple. 
You just need to write a Bash script (or R, or Python) which runs the executable multiple
times, and verifies the output. Take note that the test needs to produce an error code not equal to
0 when a mistake is found.


```{r, echo = FALSE}
print_file("test.R")
```

When running the test, viash will automatically build an executable and place it -- along with other 
resources and test resources -- in a temporary working directory.

