---
title: "Creating a Bash component"
parent: Creating components
---

# Developing a new viash component

In this tutorial, you’ll create a component that does the following:

-   Extract all hyperlinks from a markdown file
-   Check if every URL is reachable
-   Create a text report with the results

The component will be able to run locally and as a docker container. In
order to create a component you need two files: a script for the
functionality and a config file that describes the component.

The files used in this tutorial can be found here:

<https://github.com/data-intuitive/viash_docs/examples/md_url_checker>

## Prerequisites

To follow along with this tutorial, you need to have this software
installed on your machine:

-   An [installation of viash](/getting_started/installation).
-   A **Unix shell** like Bash or Zsh.
-   An installation of [Docker](https://www.docker.com/).
-   An installation of [cURL](https://curl.se/). Install this via your
    package manager if you don’t have it installed yet.

We recommend you take a look at the [hello world
example](/getting_started/hello_world_bash) first to understand how
components work.

## Write a script in Bash

The first step of developing this component, is writing the core
functionality of the component, in this case a bash script.  
Create a new folder named **my\_viash\_component** and open it. Now
create a new file named **script.sh** in there and add this code as its
content:

``` bash
#!/usr/bin/env bash

### 1 ###

## VIASH START

par_inputfile="Testfile.md"
par_domain="http://www.data-intuitive.com/viash_docs"
par_output="output.txt"

## VIASH END

amount_of_errors=0

echo "Extracting URLs"

### 2 ###

# Extract the titles and URLs from the markdown file with sed and put them into arrays
readarray -t title_array <<<$(sed -rn 's@^.*\[(.*)\]\((.*)\).*$@\1@p' $par_inputfile)
readarray -t url_array <<<$(sed -rn 's@^.*\[(.*)\]\((.*)\).*$@\2@p' $par_inputfile)

# Get length of array
amount_of_urls=$(echo "${#url_array[@]}")

echo "Checking $amount_of_urls URLs"

# Clear file
>$par_output

### 3 ###

# Iterate over the array of titles and check each URL
for ((n = 0; n < ${#title_array[*]}; n++)); do
    title="${title_array[n]}"
    url="${url_array[n]}"

    ### 4 ###

    # If an URL doesn't start with 'http', add the domain before it
    if [[ $url != http* ]]; then
        url="$par_domain${url_array[n]}"
    fi

    echo "$(($n + 1)): $url"

    echo -e "Link name: $title" >>$par_output
    echo -e "URL: $url" >>$par_output

    ### 5 ###

    # Do a cURL and get the status code from the last response after following any redirects
    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)
    expected_code="200"

    # Check if status code obtained via cURL contains the expected code
    if [[ $status_code == *$expected_code* ]]; then
        echo "OK"
        echo -e "Status: OK, can be reached." >>$par_output
    else
        echo $status_code
        echo -e "Status: ERROR! URL cannot be reached. Status code: $status_code" >>$par_output
        amount_of_errors=$(($amount_of_errors + 1))
    fi

    echo -e "---" >>$par_output
done

echo ""
echo "$par_inputfile has been checked and a report named $par_output has been generated.
$amount_of_errors of $amount_of_urls URLs could not be resolved."
```

Note the numbered comments scattered about looking like `### x ###`,
here’s a breakdown of the code:

1.  The variables are placed between `## VIASH START` and `## VIASH END`
    for debugging purposes, their final values will be dynamically
    generated by viash once the script is turned into a component. If
    you want to skip the testing of your script, you can leave these out
    and viash will create variables based on the configuration file.
    There are three variables:
    -   `par_inputfile`: The markdown file that needs to be parsed.
    -   `par_domain`: The domain URL that gets inserted before any
        relative URLs. For example, “/documentation/intro” could be
        replaced with “<https://my-website/documentation/intro>” to
        create a valid URL.
    -   `par_output`: The path of the output text file that will contain
        the report.
2.  The script parses the markdown file and extracts the hyperlink
    titles and URLs using some nifty
    [sed](https://www.gnu.org/software/sed/manual/sed.html) regex. It
    then puts those strings into two arrays for later use.
3.  Start a for-loop to iterate the title array.
4.  Any relative URLs (or those that don’t start with “http” at least)
    will get the domain added before it.
5.  cURL is used to check for a response from the URL. The resulting
    status code is stored and compared to the expected code. The results
    get written to the terminal and the report.

## Test the script

Before turning the script into a component, it’s a good idea to test if
it actually works as expected.  
As the script expects a markdown file with hyperlinks, create a new file
in the script folder named **Testfile.md** and paste in the following:

``` markdown
# Test File

This is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.
Some links to websites:

- [Google](https://www.google.com)
- [Reddit](https://www.reddit.com)
- [A broken link](http://microsoft.com/random-link)

Links that are relative to [Viash Docs](http://www.data-intuitive.com/viash_docs/):

- You can [install viash here](/getting_started/installation).
- It's important to write [tests](/good_practices/testing) for your components.
```

Now open a terminal in the folder and execute the following command to
make your script executable:

``` bash
chmod +x ./script.sh
```

Next, run the script by executing this command:

``` bash
./script.sh
```

The script will now show the following output:

    Extracting URLs
    Checking 6 URLs
    1: https://www.google.com
    OK
    2: https://www.reddit.com
    OK
    3: http://microsoft.com/random-link
    HTTP/2 404 
    4: http://www.data-intuitive.com/viash_docs/
    OK
    5: http://www.data-intuitive.com/viash_docs/getting_started/installation
    OK
    6: http://www.data-intuitive.com/viash_docs/good_practices/testing
    OK

    Testfile.md has been checked and a report named output.txt has been generated.
    1 of 6 URLs could not be resolved.

If you get this same output, that means the script is working as
intended! Feel free to take a peek at the generated **output.txt** file
as well. You might have noticed you didn’t have to provide any
arguments, that’s because the values are hard-coded into the script for
debugging purposes.

Now the script has been tested, it’s time to create a config file to
describe the component based on it.

## Describe the component using YAML

A **viash config file** is a [YAML](https://yaml.org/) file that
describes the behavior and supported platforms of a viash component.
Create new file named **config.vsh.yaml** and paste the following
template inside of it:

``` yaml
functionality:
  name: NAME
  description: DESCRIPTION
  arguments:                     
  - type: string
    name: --input
    description: INPUT DESCRIPTION
  resources:
  - type: LANGUAGE_script
    path: SCRIPT
platforms:
  - type: native
```

Every config file requires these two dictionaries:
[functionality](http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#functionality)
and
[platforms](http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#platforms).
This bare-bones config file makes it easy to “fill in the blanks” for
this example. For more information about config files, you can take a
look at the [Config](/config) page.

Let’s start off by defining the functionality of our component.

### Defining the functionality

The **functionality** dictionary describes what the component does and
the resources it needs to do so. The first key is **name**, this will be
the name of the component once it’s built. Replace the **NAME** value
with **md\_url\_checker** or any other name of your choosing.

Next up is the **description** key, its value will be printed out at the
top when the **–help** command is called. Replace **DESCRIPTION** with
“**Check if URLs in a markdown are reachable and create a text report
with the results.**”. You can use multiple lines for a description by
starting its value with a pipe (\|) and a new line, like so:

``` yaml
functionality:
  name: md_url_checker
  description: |
    This is the first line of my description.
    Here's a second line!
```

The **arguments** dictionary contains all of the arguments that are
accepted by the component. These arguments will be injected as variables
in the script. In the case of the example script, this are the variables
we’re working with:

-   `par_inputfile`
-   `par_domain`
-   `par_output`

To create good arguments, you need to ask yourself a few essential
questions about each variable:

-   What is the most fitting [data
    type](config/functionality/#arguments-list)?
-   Is it an input or an output?
-   Is it required?

Let’s take a closer look at `par_inputfile` for starters:

We know it’s a file, as the script needs the path to a markdown **file**
as its **input**. It’s also definitely a **required** variable, as the
script would be pointless without it.  
With this in mind, modify the first argument as follows:

-   Change **type**’s value to **file**.
-   Set **name**’s value to **–inputfile**. The name of an argument has
    to match the variable name as the argument will be injected into the
    final script. In the case of **bash** scripts, the variable name
    gets a **‘par\_’** prefix add to it. This is the reason why the
    script variables all start with **‘par\_’**.
-   Use “**The input markdown file.**” for the **description** value.
    This description will be included when the **–help** option is
    called.
-   Add a new key named **required** and set its value to **true**. This
    ensures that the component will not be run without a value for this
    argument.
-   Add another key, name it **must\_exist** and set its value to
    **true**. This key is unique to **file** type arguments, it adds
    extra logic to the component to check if a file exists before
    running the component. This saves you from having to do this check
    yourself in the script.

That’s it for the first argument! The result should look like this:

``` yaml
  - type: file
    name: --inputfile
    description: The input markdown file.
    required: true
    must_exist: true
```

Now for `par_domain`, this is a simple **optional string** that gets
added before relative URLs. Make room for a new argument by creating a
new line below `must_exist: true` and press **Shift + Tab** to back up
one tab so the cursor is aligned with the start of the first argument.
Add the `--domain` argument here:

``` yaml
  - type: string                           
    name: --domain
    description: The domain URL that gets inserted before any relative URLs. For example, "/documentation/intro" could be replaced with "https://my-website/documentation/intro" to create a valid URL.
```

If an argument isn’t required, you can simply omit the **required** key.
Again, the variable name in the script will get the \*\*’\_par’\*\*
prefix added automatically in bash scripts. Here’s what the arguments
dictionary look like up until now:

``` yaml
  arguments:                     
  - type: file
    name: --inputfile
    description: The input markdown file.
    required: true
    must_exist: true
  - type: string                           
    name: --domain
    description: The domain URL that gets inserted before any relative URLs. For example, "/documentation/intro" could be replaced with "https://my-website/documentation/intro" to create a valid URL.
```

The final variable to create an argument for is `par_output`. This is
another **file** and clearly an **output**. Its value **isn’t required**
as we can use a **default** path if no explicit value is given.  
Add yet another new argument with the following keys and values:

-   Add a **type** key and set **file** as its value.
-   The next key is **name**, use **–output** as its value.
-   For the **description**, use “**The path of the output text file
    that will contain the report.**”.
-   Add a new key and name it **default**. This will act as the default
    value when not specified by the user of the component. Set its value
    to **“output.txt”**, including the quotation marks.
-   Finally, add the **direction** key and set its value to **output**.
    This specifies the direction of an argument as either **input** or
    **output**, with input being the default. Specifying that an
    argument is an output is important so the component can correctly
    handle the writing of files and the passing of values in a pipeline.

The finished argument should look like this:

``` yaml
  - type: file                           
    name: --output
    description: The path of the output text file that will contain the report.
    default: "output.txt"
    direction: output
```

With that, there’s just one more part of the functionality to fill in:
the script itself!  
Every viash component has one or more resources, the most important of
which is often the script. The template already contains a **resources**
dictionary, so replace the following values to point to the script:

-   Set the value of **type** to **bash\_script**. The script used in
    this case was written in **bash**, so the resource type is set
    accordingly so viash knows what flavor of code to generate to create
    the final component. You can find a full overview of the different
    resource types on the [Functionality
    page](/config/functionality/#resources-list).
-   Change the value of **path** to **script.sh**. This points to the
    resource and can be a relative path, an absolute path or even a URL.
    In this case we keep the script in the same directory as the config
    file to keep things simple.

That finishes up the functionality side of the component! All that’s
left is defining the platforms with their dependencies and then running
and building the component.

### Defining the platforms

The platforms dictionary specifies the requirements to execute the
component on zero or more platforms. The list of currently supported
platforms are [Native](config/platform-native),
[Docker](config/platform-docker), and
[Nextflow](config/platform-nextflow). If no platforms are specified, a
native platform is assumed. Here’s a quick overview of the platforms:

-   **native**: The platform for developers that know what they’re doing
    or for simple components without any dependencies. All dependencies
    need to be installed on the system the component is run on.
-   **docker**: This platform is recommended for most components. The
    dependencies are resolved by using [docker](https://www.docker.com/)
    containers, either from scratch or by pulling one from a docker
    repository. This has huge benefits as the end user doesn’t need to
    have any of the dependencies installed locally.
-   **nextflow**: This converts the component into a
    [NextFlow](https://www.nextflow.io/) module that can be imported
    into a pipeline.

In this tutorial, we’ll take a look at both the native and docker
platforms. The platforms are also defined in the **config.vsh.yaml**
file at the very bottom. The native platform is actually already defined
in the template, that one **type** key with a value of **native** is
enough! Now for adding the docker platform, add a new line below the
last and add the following:

``` yaml
  - type: docker
    image: bash:latest
```

This tells viash that this component can be built to a docker container
with the [latest bash image](https://hub.docker.com/_/bash) as its base.
If your script doesn’t depend on any packages, this would be all you’d
have to add when using a bash script. The script in our example however
needs **curl** installed to work. Luckily, this isn’t a problem since
viash [supports defining dependencies](config/platform-docker/#example)
which then get pulled from inside the docker container before running
the script. To add curl as a dependancy that needs to be installed, add
these lines below `image: bash:latest`:

``` yaml
    setup:
      - type: apk
        packages: [ curl ]
```

This will prompt the
[apk](https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management)
package manager to download and install curl inside of the container.
That’s it for the config! Be sure to save it and let’s move on to
actually running the component you’ve created. For reference, you can
take a look at the completed **config.vsh.yaml** file in [our Github
repository](https://github.com/data-intuitive/viash_docs/tree/master/examples/md_url_checker/config.vsh.yaml).

## Run the component

Time to run the component! First off, let’s see what the output of
`--help` is. To do that, open a terminal in the **my\_viash\_component**
folder and execute the following command:

``` bash
viash run config.vsh.yaml -- --help
```

This will show the following:

    Check if URLs in a markdown are reachable and create a text report with the results.

    Options:
        --inputfile=file
            type: file, required parameter
            The input markdown file.

        --domain=string
            type: string
            The domain URL that gets inserted before any relative URLs. For example, /documentation/intro could be replaced with https://my-website/documentation/intro to create a valid URL.

        --output=file
            type: file, default: output.txt
            The path of the output text file that will contain the report.

As you can see, the values you entered into the config file are all
here.  
Next, let’s run the component natively with some arguments. You can use
one of your own markdown files as the input if you desire. In that case,
replace **Testfile.md** in the command with the path to your file.  
Execute the following command to run the component with the default
platform, in this case **native** as it’s the first in the **platforms**
dictionary:

``` bash
viash run config.vsh.yaml -- --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt
```

If all goes well, you’ll see something like this output in the terminal
and a file named **my\_report.txt** will have appeared:

    Extracting URLs
    Checking 6 URLs
    1: https://www.google.com
    OK
    2: https://www.reddit.com
    OK
    3: http://microsoft.com/random-link
    HTTP/2 404 
    4: http://www.data-intuitive.com/viash_docs/
    OK
    5: http://www.data-intuitive.com/viash_docs//getting_started/installation
    OK
    6: http://www.data-intuitive.com/viash_docs//good_practices/testing
    OK

    Testfile.md has been checked and a report named my_report.txt has been generated.
    1 of 6 URLs could not be resolved.

For more information on the run command, take a look at [the viash run
command page](/commands/run/). Great! With that working, the next step
is building an executable.

## Building an executable

You can generate an executable using either the native or the docker
platform. The former will generate a file that can be run locally, but
depends on your locally installed software packages to work. A docker
executable on the other hand can build and start up a docker container
that handles the dependencies for you.  
To create a native build, execute the following command:

``` bash
viash build config.vsh.yaml
```

A new folder named **output** will have been created with an executable
inside named **md\_url\_checker**. To test it out, execute the following
command:

``` bash
output/md_url_checker --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt
```

The output is the same as by running the component, but the executable
can be easily shared and now includes the ability to feed arguments to
it and an included `--help` command. Not bad!  
Next up is the docker executable. You can specify the platform with the
`-p` argument and choose an output folder using `-o`, apart from that
it’s the same as the previous build command:

``` bash
viash build -p docker -o docker_output config.vsh.yaml 
```

You’ll now have a **docker\_ouput** folder alongside the **output** one.
This folder also contains a file named md\_url\_checker, but its inner
workings are slightly different.  
If you would simply run this file as with the native executable, you
would run into an error as the docker container needs to be built first.
You can let the executable prepare a docker container for you by using
this command:

``` bash
docker_output/md_url_checker ---setup
```

This is a one time action for every docker executable. The output will
look similar to this:

    > docker build -t md_url_checker:latest /tmp/viashsetupdocker-md_url_checker-COeCgO

Once that has finished, you can execute **md\_url\_checker** as if it
was a native executable, but it will pass its arguments to the docker
container:

``` bash
docker_output/md_url_checker --inputfile=Testfile.md --domain=http://www.data-intuitive.com/viash_docs/ --output=my_report.txt
```

For more information about the viash build command, take a look at [its
command page](/commands/build/). That concludes the building of
executables based on components using viash!

<!-- ## Writing a unit test -->
<!-- To ensure that your component works as expected during its development cycles, writing one or more tests is essential. -->
<!-- Writing a unit test for a viash component is relatively simple.  -->
<!-- You just need to write a Bash script (or R, or Python) which runs the executable multiple -->
<!-- times, and verifies the output. Take note that the test needs to produce an error code not equal to -->
<!-- 0 when a mistake is found. -->
<!-- TODO: Add unit test -->
<!-- When running the test, viash will automatically build an executable and place it -- along with other  -->
<!-- resources and test resources -- in a temporary working directory. -->

## What’s next?

Now you’re ready to use viash to creating components from your own
scripts, check out the rest of our documentation on the left. Here are
some good starting points:

-   The [viash commands](/commands/)
-   An [overview of the functionality
    dictionary](/config/functionality/) of the config file
-   More details about [the docker platform](/config/platform-docker/)
