---
title: "Creating a Bash component"
parent: Creating components
---

# Developing a new viash component

In this tutorial, you’ll create a component that does the following:

-   Extract all hyperlinks from a markdown file
-   Check if every URL is reachable
-   Create a text report with the results

The component will be able to run locally and as a docker container. In
order to create a component you need two files: a script for the
functionality and a config file that describes the component.

The files used in this tutorial can be found here:

<https://github.com/data-intuitive/viash_docs/examples/md_url_checker>

## Prerequisites

To follow along with this tutorial, you need to have this software
installed on your machine:

-   An [installation of viash](/getting_started/installation).
-   A **Unix shell** like Bash or Zsh.
-   An installation of [Docker](https://www.docker.com/).
-   An installation of [cURL](https://curl.se/). Install this via your
    package manager if you don’t have it installed yet.

We recommend you take a look at the [hello world
example](/getting_started/hello_world_bash) first to understand how
components work.

## Write a script in Bash

The first step of developing this component, is writing the core
functionality of the component, in this case a bash script.  
Create a new folder named **my\_viash\_component** and open it. Now
create a new file named **script.sh** in there and add this code as its
content:

``` bash
#!/usr/bin/env bash

### 1 ###

## VIASH START

par_inputfile="Testfile.md"
par_domain="http://www.data-intuitive.com/viash_docs"
par_output="output.txt"

## VIASH END

amount_of_errors=0

echo "Extracting URLs"

### 2 ###

# Extract the titles and URLs from the markdown file with sed and put them into arrays
readarray -t title_array <<<$(sed -rn 's@^.*\[(.*)\]\((.*)\).*$@\1@p' $par_inputfile)
readarray -t url_array <<<$(sed -rn 's@^.*\[(.*)\]\((.*)\).*$@\2@p' $par_inputfile)

# Get length of array
amount_of_urls=$(echo "${#url_array[@]}")

echo "Checking $amount_of_urls URLs"

# Clear file
>$par_output

### 3 ###

# Iterate over the array of titles and check each URL
for ((n = 0; n < ${#title_array[*]}; n++)); do
    title="${title_array[n]}"
    url="${url_array[n]}"

    ### 4 ###

    # If an URL doesn't start with 'http', add the domain before it
    if [[ $url != http* ]]; then
        url="$par_domain${url_array[n]}"
    fi

    echo "$(($n + 1)): $url"

    echo -e "Link name: $title" >>$par_output
    echo -e "URL: $url" >>$par_output

    ### 5 ###

    # Do a cURL and get the status code from the last response after following any redirects
    status_code=$(curl -ILs --max-redirs 5 $url | tac | grep -m1 HTTP)
    expected_code="200"

    # Check if status code obtained via cURL contains the expected code
    if [[ $status_code == *$expected_code* ]]; then
        echo "OK"
        echo -e "Status: OK, can be reached." >>$par_output
    else
        echo $status_code
        echo -e "Status: ERROR! URL cannot be reached. Status code: $status_code" >>$par_output
        amount_of_errors=$(($amount_of_errors + 1))
    fi

    echo -e "---" >>$par_output
done

echo ""
echo "$par_inputfile has been checked and a report named $par_output has been generated.
$amount_of_errors of $amount_of_urls URLs could not be resolved."
```

Note the numbered comments scattered about looking like `### x ###`,
here’s a breakdown of the code:

1.  The variables are placed between `## VIASH START` and `## VIASH END`
    for debugging purposes, their final values will be dynamically
    generated by viash once the script is turned into a component. If
    you want to skip the testing of your script, you can leave these out
    and viash will create variables based on the configuration file.
    There are three variables:
    -   `par_inputfile`: The markdown file that needs to be parsed.
    -   `par_domain`: The domain URL that gets inserted before any
        relative URLs. For example, “/documentation/intro” could be
        replaced with “<https://my-website/documentation/intro>” to
        create a valid URL.
    -   `par_output`: The path of the output text file that will contain
        the report.
2.  The script parses the markdown file and extracts the hyperlink
    titles and URLs using some nifty
    [sed](https://www.gnu.org/software/sed/manual/sed.html) regex. It
    then puts those strings into two arrays for later use.
3.  Start a for-loop to iterate the title array.
4.  Any relative URLs (or those that don’t start with “http” at least)
    will get the domain added before it.
5.  cURL is used to check for a response from the URL. The resulting
    status code is stored and compared to the expected code. The results
    get written to the terminal and the report.

## Test the script

Before turning the script into a component, it’s a good idea to test if
it actually works as expected.  
As the script expects a markdown file with hyperlinks, create a new file
in the script folder named **Testfile.md** and paste in the following:

``` markdown
# Test File

This is a simple markdown file with some hyperlinks to test if the check_if_URLS_reachable component works correctly.
Some links to websites:

- [Google](https://www.google.com)
- [Reddit](https://www.reddit.com)
- [A broken link](http://microsoft.com/random-link)

Links that are relative to [Viash Docs](http://www.data-intuitive.com/viash_docs/):

- You can [install viash here](/getting_started/installation).
- It's important to write [tests](/good_practices/testing) for your components.
```

Now open a terminal in the **my\_viash\_component** folder and execute
the following command to make your script executable:

``` bash
chmod +x ./script.sh
```

Next, run the script by executing this command:

``` bash
./script.sh
```

The script will now show the following output:

    Extracting URLs
    Checking 6 URLs
    1: https://www.google.com
    OK
    2: https://www.reddit.com
    OK
    3: http://microsoft.com/random-link
    HTTP/2 404 
    4: http://www.data-intuitive.com/viash_docs/
    OK
    5: http://www.data-intuitive.com/viash_docs/getting_started/installation
    OK
    6: http://www.data-intuitive.com/viash_docs/good_practices/testing
    OK

    Testfile.md has been checked and a report named output.txt has been generated.
    1 of 6 URLs could not be resolved.

If you get this same output, that means the script is working as
intended! Feel free to take a peek at the generated **output.txt** file
as well. You might have noticed you didn’t have to provide any
arguments, that’s because the values are hard-coded into the script for
debugging purposes.

Now the script has been tested, it’s time to create a config file to
describe the component based on it.

## Describe the component using YAML

A **viash config file** is a [YAML](https://yaml.org/) file that
describes the behavior and supported platforms of a viash component.
Create new file named **config.vsh.yaml** and paste the following
template inside of it:

``` yaml
functionality:
  name: NAME
  description: DESCRIPTION
  arguments:                     
  - type: string
    name: --input
    description: INPUT DESCRIPTION
  resources:
  - type: LANGUAGE_script
    path: SCRIPT
platforms:
  - type: native
```

Every config file requires these two dictionaries:
[functionality](http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#functionality)
and
[platforms](http://www.data-intuitive.com/viash_docs/getting_started/hello_world_bash/#platforms).
This bare-bones config file makes it easy to “fill in the blanks” for
this example. For more information about config files, you can take a
look at the [Config](/config) page.

Let’s start off by defining the functionality of our component.

### Defining the functionality

The **functionality** dictionary describes what the component does and
the resources it needs to do so. The first key is **name**, this will be
the name of the component once it’s built. Replace the **NAME** value
with **md\_url\_checker** or any other name of your choosing.

Next up is the **description** key, its value will be printed out at the
top when the **–help** command is called. Replace **DESCRIPTION** with
“**Check if URLs in a markdown are reachable and create a text report
with the results.**”. You can use multiple lines for a description by
starting its value with a pipe (\|) and a new line, like so:

``` yaml
functionality:
  name: md_url_checker
  description: |
    This is the first line of my description.
    Here's a second line!
```

The **arguments** dictionary contains all of the arguments that are
accepted by the component. These arguments will be injected as variables
in the script. In the case of the example script, this are the variables
we’re working with:

-   `par_inputfile`
-   `par_domain`
-   `par_output`

To create good arguments, you need to ask yourself a few essential
questions about each variable:

-   What is the most fitting [data
    type](config/functionality/#arguments-list)?
-   Is it an input or an output?
-   Is it required?

Let’s take a closer look at `par_inputfile` for starters:

We know it’s a file, as the script needs the path to a markdown **file**
as its **input**. It’s also definitely a **required** variable, as the
script would be pointless without it.  
With this in mind, modify the first argument as follows:

-   Change **type**’s value to **file**.
-   Set **name**’s value to **–inputfile**. The name of an argument has
    to match the variable name as the argument will be injected into the
    final script. In the case of **bash** scripts, the variable name
    gets a **‘par\_’** prefix add to it. This is the reason why the
    script variables all start with **‘par\_’**.
-   Use “**The input markdown file.**” for the **description** value.
    This description will be included when the **–help** option is
    called.
-   Add a new key named **required** and set its value to **true**. This
    ensures that the component will not be run without a value for this
    argument.
-   Add another key, name it **must\_exist** and set its value to
    **true**. This key is unique to **file** type arguments, it adds
    extra logic to the component to check if a file exists before
    running the component. This saves you from having to do this check
    yourself in the script.

That’s it for the first argument! The result should look like this:

``` yaml
  - type: file
    name: --inputfile
    description: The input markdown file.
    required: true
    must_exist: true
```

Now for `par_domain`, this is a simple **optional string** that gets
added before relative URLs. Make room for a new argument by creating a
new line below `must_exist: true` and press **Shift + Tab** to back up
one tab so the cursor is aligned with the start of the first argument.
Add the `--domain` argument here:

``` yaml
  - type: string                           
    name: --domain
    description: The domain URL that gets inserted before any relative URLs. For example, "/documentation/intro" could be replaced with "https://my-website/documentation/intro" to create a valid URL.
```

If an argument isn’t required, you can simply omit the **required** key.
Again, the variable name in the script will get the \*\*’\_par’\*\*
prefix added automatically in bash scripts. Here’s what the arguments
dictionary look like up until now:

``` yaml
  arguments:                     
  - type: file
    name: --inputfile
    description: The input markdown file.
    required: true
    must_exist: true
  - type: string                           
    name: --domain
    description: The domain URL that gets inserted before any relative URLs. For example, "/documentation/intro" could be replaced with "https://my-website/documentation/intro" to create a valid URL.
```

The final variable to create an argument for is `par_output`. This is
another **file** and clearly an **output**. Its value **isn’t required**
as we can use a **default** path if no explicit value is given.  
Add yet another new argument with the following keys and values:

-   Add a **type** key and set **file** as its value.
-   The next key is **name**, use **–output** as its value.
-   For the **description**, use “**The path of the output text file
    that will contain the report.**”.
-   Add a new key and name it **default**. This will act as the default
    value when not specified by the user of the component. Set its value
    to **“output.txt”**, including the quotation marks.
-   Finally, add the **direction** key and set its value to **output**.
    This specifies the direction of an argument as either **input** or
    **output**, with input being the default. Specifying that an
    argument is an output is important so the component can correctly
    handle the writing of files and the passing of values in a pipeline.

The finished argument should look like this:

``` yaml
  - type: file                           
    name: --output
    description: The path of the output text file that will contain the report.
    default: "output.txt"
    direction: output
```

With that, there’s just one more part of the functionality to fill in:
the script itself!  
Every viash component has one or more resources, the most important of
which is often the script. The template already contains a **resources**
dictionary, so replace the following values to point to the script:

-   Set the value of **type** to **bash\_script**. The script used in
    this case was written in **bash**, so the resource type is set
    accordingly so viash knows what flavor of code to generate to create
    the final component. You can find a full overview of the different
    resource types on the [Functionality
    page](/config/functionality/#resources-list).
-   Change the value of **path** to **script.sh**. This points to the
    resource and can be a relative path, an absolute path or even a URL.
    In this case we keep the script in the same directory as the config
    file to keep things simple.

That finishes up the functionality side of the component! All that’s
left is defining the platforms with their dependencies and then running
and building the component.

### Defining the platforms

What platforms do you want the component to run on and what are the
dependencies?

native = for developers that know what they’re doing or for simple
components without any dependencies docker = recommended for most
components, the dependencies are resolved by using docker containers,
either from scratch or by pulling one from a docker repository. This has
huge benefits as the end user doesn’t need to have any of the
dependencies installed locally. nextflow = this converts the component
into NextFlow module that can be imported into a pipeline

The platforms section specifies the requirements to execute the
component on zero or more platforms. The list of currently supported
platforms are [Native](config/platform-native),
[Docker](config/platform-docker), and
[Nextflow](config/platform-nextflow). If no platforms are specified, a
native platform with no system requirements is assumed.

This example component will support both the native and docker platform

### Creating a final config file

The end result should look like this:

``` yaml
functionality:
  name: md_url_checker
  description: Check if URLs in a markdown are reachable and create a text report with the results.
  arguments:                     
  - type: file
    name: --inputfile
    description: The input markdown file.
    required: true
    must_exist: true
  - type: string                           
    name: --domain
    description: The domain URL that gets inserted before any relative URLs. For example, "/documentation/intro" could be replaced with "https://my-website/documentation/intro" to create a valid URL.
  - type: file                           
    name: --output
    description: The path of the output text file that will contain the report.
    default: "output.txt"
    direction: output
  resources:
  - type: bash_script
    path: script.sh
platforms:
  - type: native
  - type: docker
    image: bash:latest
    setup:
      - type: apk
        packages: [ curl ]
```

## Run the component

You can now also use one of your own markdown files as the input. In
that case, replace **Testfile.md** in the command with the path to your
file.

## Building an executable

## Writing a unit test

To ensure that your component works as expected during its development
cycles, writing one or more tests is essential.

Writing a unit test for a viash component is relatively simple. You just
need to write a Bash script (or R, or Python) which runs the executable
multiple times, and verifies the output. Take note that the test needs
to produce an error code not equal to 0 when a mistake is found.

TODO: Add unit test

When running the test, viash will automatically build an executable and
place it – along with other resources and test resources – in a
temporary working directory.
